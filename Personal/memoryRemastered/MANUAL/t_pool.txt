PART (1)						MemoryRemastered manual							PART (1)

NAME

	new_pool, create_pool, free_pool, pool_alloc, pool_state, pool_arrayAlloc, pool_dup

SYNOPSIS
	
	#include <t_pool.h>

	t_pool *
	new_pool(size_t size);

	t_pool *
	create_pool(void);

	void
	free_pool(t_pool *pool);

	void *
	pool_alloc(t_pool *pool, size_t size);

	int
	pool_state(t_pool *pool);

	void **
	pool_arrayAlloc(t_pool *pool, size_t *sizes);

	t_pool *
	pool_dup(t_pool *pool);

DESCRIPTION

	The new_pool() and create_pool() functions both allocate a t_pool structure
	for further use.

	The new_pool() function takes a size_t (unsigned int) as an argument and
	returns a pointer to an t_pool structure. The t_pool structure returned can
	handle up to size bytes of memory. If size is zero, a NULL pointer is
	returned. If the function is not able to allocate size bytes of memory,
	it returns a NULL pointer and sets errno to ENOMEM. (see "errno.h" for
	precision).

	The create_pool() is a convenience function allocating a pool of
	DEFAULT_SIZE (defined in "t_pool.h") bytes. It reacts like new_pool()
	on error.

	The free_pool() function takes a t_pool pointer which the user does not need
	anymore to give the memory back to the system.

	The pool_alloc() and pool_arrayAlloc() functions "allocates" memory from
	an existing pool (passed as an argument), either in the form of a pointer
	or in the form of an dynamic array of pointers. On error, which means if
	there is not enough space in the pool, both functions return a NULL pointer
	and set errno to ENOMEM. If the 'size' argument sent to pool_alloc() is nul
	a NULL pointer is also returned.

	The 'sizes' array sent to pool_arrayAlloc() must be nul-terminated,
	otherwise behaviour is undefined.

	The pool_state() function returns the state of a pool at a given point
	of execution, meaning the remaining available space in this pool.

	The pool_dup() function returns a strict duplicate of a given pool.
	Note that the memory of the pool itself is copied. This means that the
	resulting pool is not zero-filled. Moreover there is no way (other than
	manually) of getting the pointers in the copy of the pool corresponding
	to the original one. Generally speaking, it is advised to avoid using
	this function too often. If you need pools that handle copy, size changes,
	realloc etc, see the t_oPool structure in the second part of this file.

RETURN VALUES

	The functions new_pool() and create_pool() will return a usable t_pool
	structure on success, a NULL pointer on error.

	The free_pool() function does not return anything.

	If passed a valid pool (aka. not NULL), the pool_state() function
	returns the available memory space in it. Else the return value will always
	be 0.

	The pool_alloc() and pool_arrayAlloc() will respectively return a valid
	memory array of size bytes and a valid array of memory arrays of sizes[n]
	bytes (for the (n-1)th compartment of the array). If arguments a invalid
	or if an error occurs during allocation, NULL is returned.

	If successful, the pool_dup() function returns a valid t_pool pointer that
	points to an exact copy of the pool passed in argument to the function.
	On error, NULL is returned.

STRUCTURE
	
	The t_pool structure is defined as follows.

	typedef struct		s_pool
	{
		void			*pool;
		size_t			size;
		size_t			used;
		size_t			counter;
	}					t_pool;

	Note that one should not modify directly those attributes since it may
	completely disrupt the behaviour of all the features.